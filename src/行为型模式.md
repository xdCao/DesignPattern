#职责链模式

##定义
    避免将请求发送者与接受者耦合在一起，让多个对象都有机会请求，将这些对象连接成一条链，并且沿着这条链传递请求，
    直到有对象处理它为止。
##纯责任链
    要求具体处理者对象只能在两种行为中选择一个，要么承担责任，要么将责任推给下家，不允许一个处理者在承担了一部分
    或全部责任后又将责任下发的情况。并且要求请求必须被一个处理者对象所接受。
##不纯的责任链
    允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完请求后其后继处理者可以继续处理该请求
    ，而且一个请求可以最终不被任何处理者对象所接受
##优点
    1、职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象只需知道该请求会被处理即可，接受者和发送者
    都没有对方的明确信息，且链中的对象不需要知道链中的结构，由客户端负责链的创建，降低了系统的耦合度
    2、在给对象分派职责时，职责链可以提供更多的灵活性，可以通过运行时对链动态的添加或修改来增加或改变处理
    一个请求的职责
    3、符合开闭原则
##缺点 
    1、由于一个请求没有明确的处理者，那么不能保证他一定会被处理，一个请求也可能因为职责链没有正确配置而得不到处理
    2、对于比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便
##场景
    1、由多个对象处理请求，具体哪个对象处理请求待运行时再确定，客户端只需将请求提交到链上
    2、在不明确指定接受者的情况下，向多个对象中的一个提交一个请求
    3、可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的次序

#命令模式（请求发送者与接收者解耦） 别名：动作模式/事务模式

##定义
    将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销
    的操作
    每一个具体的命令类对应一个请求的处理者，通过向请求发送者注入不同的具体命令对象可以使得相同的发送者对应
    不同的接收者，从而实现“将一个请求封装为一个对象，用不同的请求对客户进行参数化”。客户端只需要将具体的命令对象
    作为参数注入请求发送者，无须直接操作请求的接收者。
##优点
    1、降低请求者与接收者的耦合
    2、扩展性好，新的命令可以很容易的加入到系统中
    3、可以比较容易的设计一个命令队列或宏命令（组合命令）
    4、为请求的撤销和恢复操作提供了一种设计和实现方案
##缺点
    可能会导致某些系统有过多的具体命令类
##使用场景
    1、系统需要将请求者和接收者解耦，使得调用者和接收者不直接交互
    2、系统需要在不同的时间指定请求，将请求排队和执行请求。一个命令对象和请求的调用者可以有不同的生命期。换言之，
    最初的请求发出者可能已经不在了，而命令对象本身依然是活动的，可以通过该命令对象去调用请求接收者，而无需关心请求
    调用者的存在性，可以通过请求日志文件等机制来具体实现
    3、系统需要支持命令的撤销操作和恢复操作
    4、系统需要将一组操作组合在一起形成宏命令
 
#解释器模式（使用频率较低，用于自定义语言的实现）

##定义
    定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码

#迭代器模式

##定义
    提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示
    在软件开发时，经常需要使用聚合对象来存储一系列数据。聚合对象拥有两个职责：一是存储数据，二是遍历数据
    从依赖性来看，前者是聚合对象的基本职责，而后者是可变化的，又是可分离的。因此可以将遍历数据的行为从
    聚合对象中分离出来，封装在一个被称为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为
##优点
    1、支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器
    来替换原有迭代器即可改变遍历算法，也可以自己定义迭代器的子类以支持新的遍历方式
    2、迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计
    3、在迭代器模式中，由于引入了抽象层，满足开闭原则的要求
##缺点
    1、类的个数增加，增加了系统的复杂性
    2、设计一个考虑全面的迭代器不容易