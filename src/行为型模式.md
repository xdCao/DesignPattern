#职责链模式

##定义
    避免将请求发送者与接受者耦合在一起，让多个对象都有机会请求，将这些对象连接成一条链，并且沿着这条链传递请求，
    直到有对象处理它为止。
##纯责任链
    要求具体处理者对象只能在两种行为中选择一个，要么承担责任，要么将责任推给下家，不允许一个处理者在承担了一部分
    或全部责任后又将责任下发的情况。并且要求请求必须被一个处理者对象所接受。
##不纯的责任链
    允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完请求后其后继处理者可以继续处理该请求
    ，而且一个请求可以最终不被任何处理者对象所接受
##优点
    1、职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象只需知道该请求会被处理即可，接受者和发送者
    都没有对方的明确信息，且链中的对象不需要知道链中的结构，由客户端负责链的创建，降低了系统的耦合度
    2、在给对象分派职责时，职责链可以提供更多的灵活性，可以通过运行时对链动态的添加或修改来增加或改变处理
    一个请求的职责
    3、符合开闭原则
##缺点 
    1、由于一个请求没有明确的处理者，那么不能保证他一定会被处理，一个请求也可能因为职责链没有正确配置而得不到处理
    2、对于比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便
##场景
    1、由多个对象处理请求，具体哪个对象处理请求待运行时再确定，客户端只需将请求提交到链上
    2、在不明确指定接受者的情况下，向多个对象中的一个提交一个请求
    3、可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的次序

#命令模式（请求发送者与接收者解耦） 别名：动作模式/事务模式

##定义
    将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销
    的操作
    每一个具体的命令类对应一个请求的处理者，通过向请求发送者注入不同的具体命令对象可以使得相同的发送者对应
    不同的接收者，从而实现“将一个请求封装为一个对象，用不同的请求对客户进行参数化”。客户端只需要将具体的命令对象
    作为参数注入请求发送者，无须直接操作请求的接收者。
##优点
    1、降低请求者与接收者的耦合
    2、扩展性好，新的命令可以很容易的加入到系统中
    3、可以比较容易的设计一个命令队列或宏命令（组合命令）
    4、为请求的撤销和恢复操作提供了一种设计和实现方案
##缺点
    可能会导致某些系统有过多的具体命令类
##使用场景
    1、系统需要将请求者和接收者解耦，使得调用者和接收者不直接交互
    2、系统需要在不同的时间指定请求，将请求排队和执行请求。一个命令对象和请求的调用者可以有不同的生命期。换言之，
    最初的请求发出者可能已经不在了，而命令对象本身依然是活动的，可以通过该命令对象去调用请求接收者，而无需关心请求
    调用者的存在性，可以通过请求日志文件等机制来具体实现
    3、系统需要支持命令的撤销操作和恢复操作
    4、系统需要将一组操作组合在一起形成宏命令
 
#解释器模式（使用频率较低，用于自定义语言的实现）

##定义 
    定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码

#迭代器模式

##定义
    提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示
    在软件开发时，经常需要使用聚合对象来存储一系列数据。聚合对象拥有两个职责：一是存储数据，二是遍历数据
    从依赖性来看，前者是聚合对象的基本职责，而后者是可变化的，又是可分离的。因此可以将遍历数据的行为从
    聚合对象中分离出来，封装在一个被称为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为
##优点
    1、支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器
    来替换原有迭代器即可改变遍历算法，也可以自己定义迭代器的子类以支持新的遍历方式
    2、迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计
    3、在迭代器模式中，由于引入了抽象层，满足开闭原则的要求
##缺点
    1、类的个数增加，增加了系统的复杂性
    2、设计一个考虑全面的迭代器不容易
    
#中介者模式(qq群)

##定义
    用一个中介对象来封装一系列的对象交互,中介者使各对象不需要显式的相互引用,从而使其耦合松散,而且可以独立的改变他们的交互.
    
    中介者模式可以使对象之间到的关系数量急剧减少,通过引入中介者对象,可以将系统的网状结构变成以中介者为中心的星型结构.在这个星型结构中,
    同事对象不再直接与另一个对象联系,它通过中介者对象与另一个对象发生相互作用.中介者对象的存在保证了对象结构上的稳定,也就是说,
    系统的结构不会因为新对象的引入带来大量的修改工作.
    
    如果在一个系统中对象之间存在多对多的相互关系,可以将对象之间的一些交互行为从各个对象中分离出来,并集中封装在一个中介者对象
    中,并由该中介者进行统一协调,这样对象之间多对多的复杂关系就转化为相对简单的一对多关系
##中介者作用
    1.中转作用(结构性):通过中介者提供的中转作用,各个同事对象不再需要显示的引用其他同事对象,当需要与其他同事进行通信时
    可通过中介者简介调用
    2.协调作用(行为性):中介者可以更进一步的对同事之间的关系进行封装,同事可以一致的和中介者进行交互,而不需要指明中介者
    具体需要怎么做,中介者根据封装在自身内部的协调逻辑,对同事的请求进行进一步处理,将同事成员之间的关系行为进行分离和封装.
##优点
    1.简化了对象之间的交互
    2.将各同事对象解耦
    3.减少大量同事子类的生成,中介者将原本分布在多个对象间的行为集中在一起
##缺点
    在具体中介者类中包含了大量同事之间的交互细节,可能会导致具体中介者类非常复杂,使得系统难以维护
    
#备忘录模式(撤销功能实现,Token)

##定义
    在不破坏封装的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态,这样可以在以后将对象恢复到原先保存的状态,别名为Token
##注意
    备忘录是一个很特殊的对象,只有原发器对它拥有控制的权力,负责人只负责管理备忘录,而其他类无法直接访问到备忘录,因此需要对备忘录进行封装
    在Java中可以将原发器类和备忘录放在一个包中,让他们满足默认的包内可见性,也可以将备忘录类作为原发器类的内部类,使得只有原发器才可以访问备忘录中
    的数据,其他对象都无法直接使用备忘录中的数据
##优点
    1.提供状态恢复的实现机制
    2.实现了对信息的封装
##缺点
    资源消耗过大,如果需要保存的原发器类的成员变量太多,就不可避免的需要占用大量的存储空间