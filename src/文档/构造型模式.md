#单例模式

##定义：
    在单例类的内部实现只生成一个实例，同时他提供一个静态getInstance方法，让客户可以访问它的唯一实例，
    为了防止在外部对单例类实例化，它的构造函数的可见性为private；在单例类内部定义一个静态对象，作为供
    外部共享访问的唯一实例
##优点：
    1、提供对唯一实例的受控访问
    2、节约系统资源
    3、允许可变数目的实例（多例，既解决单例共享过多有损性能的问题，又节省了系统资源）
##缺点
    1、单例模式没有抽象层，难以扩展
    2、职责过重，违背单一职责原则
    3、自动垃圾回收可能导致对象丢失
##懒汉、饿汉、IoDH
    懒汉可以延迟加载，但多线程性能差，双重检查锁中两个锁的用处
    饿汉不用担心多线程，但是无法延迟加载
    
#简单工厂模式

##定义
    定义一个工厂类，可以根据不同的参数返回不同类的实例，被创建的实例通常拥有共同的父类。由于简单工厂模式
    中创建实例的方法通常是静态方法，因此简单工厂模式又称为静态工厂方法模式
##优点
    1、实现对象创建和使用的分离
    2、方法名类名方便记忆
    3、通过引入配置文件，不用修改代码即可更换产品，提高了系统灵活性  
##缺点
    1、工厂类职责过重，一旦出错，整个系统受影响
    2、增加类的个数
    3、扩展困难，添加新产品就不得不修改工厂逻辑
    4、使用静态方法，导致无法形成基于继承的等级结构
    
#工厂方法模式

##定义
    定义一个用于创建对象的接口，让子类决定让哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类
##优点
    1、隐藏产品细节
    2、可扩展性
##缺点
    1、类的数目成对增加，增加系统复杂度
    2、增加了抽象性和理解难度
##使用场景
    客户端不知道其所需要的对象的类
    
#抽象工厂模式

##定义
    提供一个创建一系列相关或互相依赖对象的接口，而无需指定他们具体的类
    在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或具体类
##优点
    1、隔离了具体类的生成
    2、当一个产品族的多个对象被设计成一起工作时，能够保证客户端始终只使用同一产品族的对象
    3、增加新的产品族很方便
##缺点
    1、添加新的产品等级结构很麻烦，需要大量修改原有系统，违背了开闭原则
##使用场景
    1、系统中有多于一个的产品族，而每次只使用其中一个产品族
    2、属于同一个产品族的产品将在一起使用
    3、产品等级结构稳定，设计完成之后，不会向系统中增加或删除产品等级结构
    
#原型模式

##定义
    使用原型实例指定创建对象的种类，并且通过克隆这些原型创建新的对象
    将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象克隆自己来实现创建过程
    原型模式的核心在于如何实现克隆方法
##优点
    1、当创建新的对象实例较为复杂时，可以简化对象的创建过程，复制、修改
    2、扩展性较好，提供了抽象原型类
##缺点
    1、需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当要改造时需要修改源代码，违背了开闭原则
    2、对象嵌套较多时，深克隆较麻烦
##场景
    1、创建新对象成本较大
    2、系统要保存对象的状态，而对象的状态变化很小，或对象本身占用对象较少，可以使用原型模式加备忘录模式
    
#建造者模式

##定义
    将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需的建造者类型即可。
    建造者模式关注如何一步步创建一个复杂对象，不同的具体建造者定义了不同的建造过程，且具体建造者相互独立，增加新的建造者非常方便
    ，不需要修改已有代码，具有较好的扩展性
##优点
    1、产品本身与创建过程解耦
    2、每一个具体建造者相对独立，与其他建造者无关，可以方便的替换或增加具体建造者
    3、利用钩子方法，可以更加精细的控制产品的创建过程
    （Hook method）
##缺点
    1、如果产品之间差异性很大，组成成分不同，就不适合用建造者模式
    2、如果产品内部结构复杂且多变，可能需要定义很多具体建造者来实现变化

