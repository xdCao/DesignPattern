#职责链模式

##定义
    避免将请求发送者与接受者耦合在一起，让多个对象都有机会请求，将这些对象连接成一条链，并且沿着这条链传递请求，
    直到有对象处理它为止。
##纯责任链
    要求具体处理者对象只能在两种行为中选择一个，要么承担责任，要么将责任推给下家，不允许一个处理者在承担了一部分
    或全部责任后又将责任下发的情况。并且要求请求必须被一个处理者对象所接受。
##不纯的责任链
    允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完请求后其后继处理者可以继续处理该请求
    ，而且一个请求可以最终不被任何处理者对象所接受
##优点
    1、职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象只需知道该请求会被处理即可，接受者和发送者
    都没有对方的明确信息，且链中的对象不需要知道链中的结构，由客户端负责链的创建，降低了系统的耦合度
    2、在给对象分派职责时，职责链可以提供更多的灵活性，可以通过运行时对链动态的添加或修改来增加或改变处理
    一个请求的职责
    3、符合开闭原则
##缺点 
    1、由于一个请求没有明确的处理者，那么不能保证他一定会被处理，一个请求也可能因为职责链没有正确配置而得不到处理
    2、对于比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便
##场景
    1、由多个对象处理请求，具体哪个对象处理请求待运行时再确定，客户端只需将请求提交到链上
    2、在不明确指定接受者的情况下，向多个对象中的一个提交一个请求
    3、可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的次序

#命令模式（请求发送者与接收者解耦） 别名：动作模式/事务模式

##定义
    将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销
    的操作
    每一个具体的命令类对应一个请求的处理者，通过向请求发送者注入不同的具体命令对象可以使得相同的发送者对应
    不同的接收者，从而实现“将一个请求封装为一个对象，用不同的请求对客户进行参数化”。客户端只需要将具体的命令对象
    作为参数注入请求发送者，无须直接操作请求的接收者。
##优点
    1、降低请求者与接收者的耦合
    2、扩展性好，新的命令可以很容易的加入到系统中
    3、可以比较容易的设计一个命令队列或宏命令（组合命令）
    4、为请求的撤销和恢复操作提供了一种设计和实现方案
##缺点
    可能会导致某些系统有过多的具体命令类
##使用场景
    1、系统需要将请求者和接收者解耦，使得调用者和接收者不直接交互
    2、系统需要在不同的时间指定请求，将请求排队和执行请求。一个命令对象和请求的调用者可以有不同的生命期。换言之，
    最初的请求发出者可能已经不在了，而命令对象本身依然是活动的，可以通过该命令对象去调用请求接收者，而无需关心请求
    调用者的存在性，可以通过请求日志文件等机制来具体实现
    3、系统需要支持命令的撤销操作和恢复操作
    4、系统需要将一组操作组合在一起形成宏命令
 
#解释器模式（使用频率较低，用于自定义语言的实现）

##定义 
    定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码

#迭代器模式

##定义
    提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示
    在软件开发时，经常需要使用聚合对象来存储一系列数据。聚合对象拥有两个职责：一是存储数据，二是遍历数据
    从依赖性来看，前者是聚合对象的基本职责，而后者是可变化的，又是可分离的。因此可以将遍历数据的行为从
    聚合对象中分离出来，封装在一个被称为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为
##优点
    1、支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器
    来替换原有迭代器即可改变遍历算法，也可以自己定义迭代器的子类以支持新的遍历方式
    2、迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计
    3、在迭代器模式中，由于引入了抽象层，满足开闭原则的要求
##缺点
    1、类的个数增加，增加了系统的复杂性
    2、设计一个考虑全面的迭代器不容易
    
#中介者模式(qq群)

##定义
    用一个中介对象来封装一系列的对象交互,中介者使各对象不需要显式的相互引用,从而使其耦合松散,而且可以独立的改变他们的交互.
    
    中介者模式可以使对象之间到的关系数量急剧减少,通过引入中介者对象,可以将系统的网状结构变成以中介者为中心的星型结构.在这个星型结构中,
    同事对象不再直接与另一个对象联系,它通过中介者对象与另一个对象发生相互作用.中介者对象的存在保证了对象结构上的稳定,也就是说,
    系统的结构不会因为新对象的引入带来大量的修改工作.
    
    如果在一个系统中对象之间存在多对多的相互关系,可以将对象之间的一些交互行为从各个对象中分离出来,并集中封装在一个中介者对象
    中,并由该中介者进行统一协调,这样对象之间多对多的复杂关系就转化为相对简单的一对多关系
##中介者作用
    1.中转作用(结构性):通过中介者提供的中转作用,各个同事对象不再需要显示的引用其他同事对象,当需要与其他同事进行通信时
    可通过中介者简介调用
    2.协调作用(行为性):中介者可以更进一步的对同事之间的关系进行封装,同事可以一致的和中介者进行交互,而不需要指明中介者
    具体需要怎么做,中介者根据封装在自身内部的协调逻辑,对同事的请求进行进一步处理,将同事成员之间的关系行为进行分离和封装.
##优点
    1.简化了对象之间的交互
    2.将各同事对象解耦
    3.减少大量同事子类的生成,中介者将原本分布在多个对象间的行为集中在一起
##缺点
    在具体中介者类中包含了大量同事之间的交互细节,可能会导致具体中介者类非常复杂,使得系统难以维护
    
#备忘录模式(撤销功能实现,Token)

##定义
    在不破坏封装的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态,这样可以在以后将对象恢复到原先保存的状态,别名为Token
##注意
    备忘录是一个很特殊的对象,只有原发器对它拥有控制的权力,负责人只负责管理备忘录,而其他类无法直接访问到备忘录,因此需要对备忘录进行封装
    在Java中可以将原发器类和备忘录放在一个包中,让他们满足默认的包内可见性,也可以将备忘录类作为原发器类的内部类,使得只有原发器才可以访问备忘录中
    的数据,其他对象都无法直接使用备忘录中的数据
##优点
    1.提供状态恢复的实现机制
    2.实现了对信息的封装
##缺点
    资源消耗过大,如果需要保存的原发器类的成员变量太多,就不可避免的需要占用大量的存储空间
    
#观察者模式

##定义
    定义对象之间的一种一对多依赖关系,使得每当一个对象状态发生改变时,其相关依赖对象皆得到通知并被自动更新.
##JDK对观察者模式的支持
    Observable(观察对象抽象),Observer(观察者抽象)
    可以直接使用Observer接口和Observable类来作为观察者模式的抽象层,再自定义具体观察者类和具体观察目标类
##观察者模式与Java事件处理
    委派事件模型(DEM)
    在DEM中,目标角色(如界面组件)负责发布事件,而观察者角色(事件处理者)可以向目标订阅它所感兴趣的事件.当一个具体目标
    产生一个事件时,它将通知所有订阅者.事件的发布者称为事件源,而订阅者称为事件监听器.在这个过程中还可以通过事件对象
    来传递与事件相关的信息,可以在事件监听者的实现类中实现事件处理,因此事件监听对象又称为事件处理对象.
##观察者模式与MVC
    模型可对应于观察者模式中的观察目标,而视图对应于观察者,控制器充当两者之间的中介者.当模型层的数据发生改变时,视图层
    将自动改变其显示内容
##优点
    1.观察者模式可以实现表示层和数据逻辑层的分离,定义了稳定的消息更新的传递机制,并抽象了更新接口,使得可以有各种各样
    不同的表示层充当具体观察者角色
    2.观察者模式在观察目标和观察者之间建立一个抽象的耦合.观察目标只需要维持一个抽象观察者的集合,无需了解其具体观察者
    .由于观察目标和观察者没有紧密的耦合在一起,因此他们可以属于不同的抽象化层次.
    3.观察者模式支持广播通信,观察目标会向所有已注册的观察者对象发送通知,简化了一对多系统的设计难度
    4.观察者模式满足开闭原则的要求,增加新的具体观察者无需修改原有系统代码,在具体观察者与观察目标之间不存在关联关系的
    情况下,增加新的观察目标也很方便
##缺点
    1.如果一个观察目标对象有很多直接和间接观察者,将所有的观察者都通知到会花费很多时间
    2.如果在观察者和观察目标之间存在循环依赖,观察目标会触发他们之间进行循环调用,可能导致系统崩溃
    3.观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的,而仅仅只是知道观察目标发生了变化
##使用场景
    1.一个抽象模型有两个方面,其中一个方面依赖另一个方面,将这两个方面封装在独立的对象中使他们可以各自独立的改变和复用
    2.一个对象的改变将导致一个或多个其他对象也发生改变,而并不知道具体有多少对象将发生改变,也不知道这些对象是谁
    3.需要在系统中创建一个触发连
    
#状态模式(对象状态及其转换)

##定义
    允许一个对象在其内部状态改变时改变它的行为,对象看起来似乎修改了它的类.
    状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题.当系统中某个对象存在多个状态,这些对象之间可以进行
    转换,而且对象在不同状态下行为不相同时可以使用状态模式.状态模式将一个对象从该对象中分离出来,封装到专门的状态类中,使得对象
    状态可以灵活变化,对于客户端而言,无需关心对象状态的转换以及对象所处的当前状态,无论对于何种状态的对象,客户端都可以一致性
    的处理
##共享状态
    在有些情况下,多个环境对象可能需要共享同一个状态,如果希望在系统中实现多个环境对象共享一个或多个状态对象,那么需要将这些状态对象
    定义为环境类的静态成员对象(着重注意)
##优点
    1.封装了状态的转换规则,在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中,可以对状态转换代码进行集中管理,
    而不是分散在一个个业务方法中
    2.将所有与某个状态有关的行为放到一个类中,只需要注入一个不同的状态对象即可使环境对象拥有不同的行为
    3.允许状态逻辑与状态对象合成一体,而不是提供一个巨大的条件语句块
    4.可以让多个环境对象共享一个状态对象,从而减少系统中对象的个数
##缺点
    1.状态模式的使用必然会增加系统中类和对象的个数,导致系统运行开销的增大
    2.程序实现和结构较为复杂
    3.对开闭原则的支持不太好
##使用场景
    1.对象的行为依赖于它的状态,状态的改变将导致行为的变化
    2.在代码中包含大量与对象状态有关的条件语句,这些条件语句的出现,会导致代码的可维护性和灵活性较差,不能方便的增加和删除状态,
    并且导致客户类与类库之间的耦合增强 
    
#策略模式(算法的封装与切换,可插入式算法实现)

##定义
    定义一系列算法类,将每一个算法封装起来,并让他们可以相互替换.策略模式让算法独立于使用它的客户而变化.
    策略模式的主要目的是将算法的定义与使用分开,也就是将算法的行为和环境分开,将算法的定义放在专门的策略类中,
    每一个策略类中封装了一种实现算法,使用算法的环境类针对抽象策略类进行编程,符合依赖倒转原则.在出现新的算法时,
    只需要增加一个新的实现了抽象策略类的具体策略类即可.
##优点
    1.提供了对开闭原则的完美支持
    2.提供了管理相关的算法族的方法.策略类的等级结构定义了一个算法或行为族,恰当使用继承可以把公用的代码移到抽象策略类
    中,从而避免重复的代码
    3.提供了一种可以替换继承关系的办法
    4.避免多重条件选择语句
    5.提供了一种算法的复用机制
##缺点
    1.客户端必须知道所有的策略类,并自行决定使用哪一个策略类.换言之,策略模式只适用于客户端知道所有算法或行为的情况
    2.造成类的数量过多
    3.无法同时在客户端使用多个策略类,也就是说,在使用策略模式时,客户端每次只能使用一个策略类,不支持使用一个策略类完成部分功能
    后再使用另一个策略类来完成剩余功能的情况
##使用场景
    1.一个系统需要动态的在几种算法中选择几种,那么可以将这些算法封装到一个个的具体算法类中,而这些具体算法类都是一个抽象算法类的
    子类.
    2.一个对象有很多的行为,如果不用恰当的模式.这些行为就只好使用多重条件选择来实现.此时,使用策略模式,把这些行为转移到响应的具体策略类
    里面,就可以避免使用难以维护的多重条件选择语句.
    3.不希望客户端知道复杂的,与算法相关的数据结构,在具体策略类中封装算法与相关的数据结构,可以提高算法的保密性与安全性
    
#模板方法模式

##定义
    定义一个操作中算法的框架,而将一些步骤延迟到子类中,模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤.
    可以将一些复杂流程的实现步骤封装在一系列基本方法中,在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序,而通过
    其子类来覆盖某些步骤,从而使得相同的算法框架可以有不同的执行结果.
##方法类型
    1.模板方法:一个模板方法是定义在抽象类中的,把基本操作方法组合在一起形成一个总算法或一个总行为的方法.这个模板方法定义在抽象类
    中,并由子类不加以修改的完全继承下来(在java中,可以将模板方法定义为final方法).模板方法是一个具体方法,它给出了一个顶层逻辑框架,
    而逻辑的组成步骤在抽象类中可以是具体方法,也可以使抽象方法.由于模板方法是具体方法,因此模板方法模式中的抽象层只能是抽象类,而不是接口
    2.基本方法
    (1)抽象方法
        由抽象类声明,由具体子类实现
    (2)具体方法
        由一个抽象类或具体类声明并实现,其子类可以进行覆盖也可以直接继承
    (3)钩子方法(子类控制父类行为)
        一个钩子方法由一个抽象类或具体类声明或实现,而其子类可能会加以扩展.通常在父类给出的实现是一个空实现,并以该空实现
        作为方法的默认实现,当然钩子方法也可以提供一个非空的默认实现
##缺点
    需要为每一个基本方法的不同实现提供一个子类,如果父类中可变基本方法太多,将会导致类的个数增加,系统更加庞大,设计也更加抽象,
    此时可结合桥接模式进行设计
    

     
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    