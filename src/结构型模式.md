#适配器模式

##定义
    将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器（Wrapper）。适配器
    模式既可以作为类结构型模式，也可以对象结构型模式
    此处提及的接口为广义的接口，它可以表示一个方法或方法的集合
#优点
    1、将目标类和支配者类解耦，通过引入一个适配器来重用现有的适配者类，无需修改原有结构
    2、增加了类的透明性和复用性，将具体业务的实现过程封装在适配者类中，并且同一个适配者类可以在多个不同的系统
    中复用
    3、灵活性和扩展性好，完全符合开闭原则
#缺点
    受java语言的一些特性限制，比如适配者不能为final，以及无法多重继承导致无法同时适配多个适配者
    
#桥接模式

##定义
    将抽象部分与实现部分分离，使他们可以互相独立的变化
    简单来说，如果有两个独立变化的维度，将其中固化的维度作为抽象形成一个继承体系，另一个维度构成另一个继承
    体系，称其为实现，在抽象中关联实现从而架起一座桥，从而在扩充功能时可以相互独立
##优点
    1、分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象
    和实现可以沿着各自的维度来变化（即抽象和实现不再在同一个继承层次结构中，而是子类化他们，使他们各自都具有
    自己的子类，以便任意组合子类，从而获得多维度组合对象）
    2、用桥接模式取代多层继承方案，极大地减少了子类的个数
    3、提高系统可扩展性，符合开闭原则
##场景
    1、如果系统需要在抽象类和具体类之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接
    模式可以使他们在抽象层建立一个关联关系
    2、抽象部分和实现部分可以以继承的方式独立扩展而互不影响，在程序运行时可以动态的将抽象类子类的对象和
    一个实现类子类的对象进行组合，即系统需要对抽象类角色和实现类角色进行动态耦合。 
    
#组合模式

##定义
    组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象和组合对象的使用具有一致性
##场景
    1、在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致性地对待他们。
    2、需要处理树形结构
    3、在一个系统中能够分离出叶子对象和容器对象，而且他们的类型不固定，需要增加一些新的类型
    
#装饰器模式

##定义
    动态的给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比子类实现更加灵活
##优点
    1、对于扩展一个对象的功能，装饰模式比继承更加具有灵活性，不会导致类的个数急剧增加
    2、可以通过动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，
    从而实现不同的行为
    3、可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的
    组合，得到功能更为强大的对象
    4、具体构件类与具体装饰类可以独立变化，用户可以根据具体需要增加新的具体构件类和具体装饰类，
    原有类库代码无须改变，符合开闭原则
##缺点
    1、使用装饰模式进行系统设计时将产生很多小对象，大量小对象的产生势必占用更多的系统资源，在一定程度上影响系统的性能
    2、装饰模式提供了一种比继承更加灵活的解决方案，但同时也以为着比继承更加易于出错，排错也更加困难，
    对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐
##适用场景
    1、在不影响其他对象的情况下，以动态、透明的方式为单个对象添加职责
    2、当不能使用继承的方式对系统进行扩展或采用继承不利于系统扩展和维护时可以使用装饰模式。
    不能采用继承的情况主要有两类：（1）系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的
    组合会产生大量的子类
                               （2）类已定义为不能被继承（final类）
##注意事项
    1、尽量保持装饰类的接口与被装饰类的接口相同，这样，对于客户端，无论是装饰之前的对象还是装饰之后的对象都可以
    一致对待，也就是说，尽可能使用透明装饰模式
    2、尽量保持具体构件类ConcreteComponent是一个轻类，，也就是说不要把太多的行为放在具体构件类中，可以通过
    装饰类对其进行扩展
    3、如果只有一个具体构件类，那么抽象装饰类可以作为该具体构建类的直接子类