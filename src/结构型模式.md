#适配器模式

##定义
    将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器（Wrapper）。适配器
    模式既可以作为类结构型模式，也可以对象结构型模式
    此处提及的接口为广义的接口，它可以表示一个方法或方法的集合
#优点
    1、将目标类和支配者类解耦，通过引入一个适配器来重用现有的适配者类，无需修改原有结构
    2、增加了类的透明性和复用性，将具体业务的实现过程封装在适配者类中，并且同一个适配者类可以在多个不同的系统
    中复用
    3、灵活性和扩展性好，完全符合开闭原则
#缺点
    受java语言的一些特性限制，比如适配者不能为final，以及无法多重继承导致无法同时适配多个适配者
    
#桥接模式

##定义
    将抽象部分与实现部分分离，使他们可以互相独立的变化
    简单来说，如果有两个独立变化的维度，将其中固化的维度作为抽象形成一个继承体系，另一个维度构成另一个继承
    体系，称其为实现，在抽象中关联实现从而架起一座桥，从而在扩充功能时可以相互独立
##优点
    1、分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象
    和实现可以沿着各自的维度来变化（即抽象和实现不再在同一个继承层次结构中，而是子类化他们，使他们各自都具有
    自己的子类，以便任意组合子类，从而获得多维度组合对象）
    2、用桥接模式取代多层继承方案，极大地减少了子类的个数
    3、提高系统可扩展性，符合开闭原则
##场景
    1、如果系统需要在抽象类和具体类之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接
    模式可以使他们在抽象层建立一个关联关系
    2、抽象部分和实现部分可以以继承的方式独立扩展而互不影响，在程序运行时可以动态的将抽象类子类的对象和
    一个实现类子类的对象进行组合，即系统需要对抽象类角色和实现类角色进行动态耦合。 
    
#组合模式

##定义
    组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象和组合对象的使用具有一致性
##场景
    1、在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致性地对待他们。
    2、需要处理树形结构
    3、在一个系统中能够分离出叶子对象和容器对象，而且他们的类型不固定，需要增加一些新的类型
    
#装饰器模式

##定义
    动态的给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比子类实现更加灵活
##优点
    1、对于扩展一个对象的功能，装饰模式比继承更加具有灵活性，不会导致类的个数急剧增加
    2、可以通过动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，
    从而实现不同的行为
    3、可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的
    组合，得到功能更为强大的对象
    4、具体构件类与具体装饰类可以独立变化，用户可以根据具体需要增加新的具体构件类和具体装饰类，
    原有类库代码无须改变，符合开闭原则
##缺点
    1、使用装饰模式进行系统设计时将产生很多小对象，大量小对象的产生势必占用更多的系统资源，在一定程度上影响系统的性能
    2、装饰模式提供了一种比继承更加灵活的解决方案，但同时也以为着比继承更加易于出错，排错也更加困难，
    对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐
##适用场景
    1、在不影响其他对象的情况下，以动态、透明的方式为单个对象添加职责
    2、当不能使用继承的方式对系统进行扩展或采用继承不利于系统扩展和维护时可以使用装饰模式。
    不能采用继承的情况主要有两类：（1）系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的
    组合会产生大量的子类
                               （2）类已定义为不能被继承（final类）
##注意事项
    1、尽量保持装饰类的接口与被装饰类的接口相同，这样，对于客户端，无论是装饰之前的对象还是装饰之后的对象都可以
    一致对待，也就是说，尽可能使用透明装饰模式
    2、尽量保持具体构件类ConcreteComponent是一个轻类，，也就是说不要把太多的行为放在具体构件类中，可以通过
    装饰类对其进行扩展
    3、如果只有一个具体构件类，那么抽象装饰类可以作为该具体构建类的直接子类
    
#外观模式（Facade）

##定义
    外部与一个子系统的通信通过一个统一的外观角色进行，为子系统中的一组接口提供一个一致的入口，外观
    模式定义了一个高层的接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式
##优点
    1、对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目并使得子系统使用起来更加容易
    2、实现了子系统与客户端之间的松耦合关系，使得子系统的变化不会影响到客户端
##缺点
    1、不能很好的限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性
    2、如果设计不当，增加新的子系统可能需要修改外观类的源代码
##使用场景
    1、要为访问一系列复杂的子系统提供一个简单入口时
    2、客户端程序与多个子系统存在很大的依赖性
    3、在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低
    层级间的耦合度
    
#享元模式（池）

##定义
    运用共享技术有效的支持大量细粒度对象的复用，系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象
    的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此又称为轻量级模式。
##优点
    1、可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能
    2、享元模式的外部状态相互独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享
##缺点
    为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长
##使用场景（String、线程池、连接池）
    1、一个系统有大量相同或相似的对象，造成内存的大量耗费
    2、对象的大部分都可以外部化，可以将这些外部状态传入对象中
    3、在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，在需要多次重复使用
    享元对象时才值得用享元模式
##与其他模式联用
    1、在享元模式的享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象
    2、在一个系统中，通常只有唯一一个享元工厂，因此可以使用单例模式进行享元工厂类的设计
    3、享元模式可以结合组合模式形成复合享元模式，同一对多个享元对象设置外部状态
    
#代理模式

##定义
    给某一个对象提供一个代理，并由代理对象控制对原对象的引用
##远程代理（RMI、RPC）
    使客户端可以访问在远程主机上的对象，远程主机可能拥有更好的计算性能和处理速度，可以快速响应并处理客户端请求。
    远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是
    局域的而不是远程的，而远程代理对象承担了大部分的网络通信工作
##虚拟代理
    虚拟代理也是一种常用的代理模式，对于一些占用资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理，
    在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象
##优点
    1、能够协调调用者和被调用者，一定程度上降低了系统的耦合度
    2、可以针对抽象主题角色进行编程，符合开闭原则，系统具有较好的灵活性和扩展性
    3、远程代理可以为位于两个不同地址空间对象的访问提供一种实现机制，可以将一些消耗资源较多的对象和操作移至性能
    更好的计算机上，提高系统的整体运行效率
    4、虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销
    5、保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限
##缺点
    1、造成请求速度变慢
    2、有些实现比较复杂
    
   